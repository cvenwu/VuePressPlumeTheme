---
title: 中华石杉课程笔记
createTime: 2024/08/16 15:06:52
permalink: /article/qg9jmsv9/
author: yirufeng
tags:
  - 面试
  - 中间件
  - kafka
  - 消息队列
---


# 消息队列

上一节课的主要内容：

1. 为什么使用MQ

2. MQ的优点和缺点，对于缺点你们公司怎么解决的

3. 不同MQ的对比，以及适用场景分析

## 高可用 - 引入消息队列后如何保证高可用

> MQ引入之后，最大的缺点就是导致我们系统可用性降低，因为MQ挂了导致整个系统通盘挂掉

📢注意：有水平的面试官问的问题是MQ如何保证高可用，言外之意就是你用过哪一个MQ，就讲哪一个MQ的高可用即可



### RabbitMQ

> 📢RabbitMQ是集群的，不是分布式的。
>
> RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式

1. 单机模式：就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式
2. 普通集群模式：意思就是在多台机器上启动多个rabbitmq实例，每个机器启动一个。但是你创建的queue（包含了元数据和实际的数据），只会放在一个rabbtimq实例上。但是每个实例都同步queue的元数据（就是队列的配置信息）。完了你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来。优点是可以提高吞吐量，但是两个缺点如下：
   1. 放queue的实例宕机了，会导致接下来其他实例就无法从那个实例拉取。如果你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，得等这个实例恢复了，然后才可以继续从这个queue拉取数据
   2. 导致RabbitMQ集群内部产生大量的数据传输![图片](/Users/cvenwu/baidunetdisk_download/Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师/06_引入消息队列之后该如何保证其高可用性？/视频/01/图片.png)
   3. 单实例性能瓶颈：queue所在的机器肯定有单机的性能瓶颈
3. 镜像集群模式：写消息到一个节点，这个节点会将消息同步到其他节点。每一个节点上都有这个queue的完整镜像，包含了queue的全部数据。这种模式，才是所谓的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。如下图所示![图片](/Users/cvenwu/baidunetdisk_download/Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师/06_引入消息队列之后该如何保证其高可用性？/视频/02/图片.png)
   1. 优点：任何一个机器宕机了，别的机器都可以用。
   2. 缺点：
      1. 性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！
      2. 不是分布式的，没有扩展性可言。比如，如果某个queue数据量很大，大到这台机器上没有容量可以容纳，因为这个策略就是每一个节点都要有所有数据。此时，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue
   3. 怎么开启这个镜像集群模式呢？rabbitmq有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，创建queue的时候可以指定我们数据分发策略，要求数据同步到所有节点的，也可以要求就同步到指定数量的节点，然后你再次创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。



### Kafka

> Kafka是分布式的，kafka部署到多台机器上，每台机器中会启动一个进程，叫做broker进程。每台机器加上机器上的broker进程，就可以认为是集群中的一个节点。Topic被划分成很多个partition，每一个partion放topic里面的一部分数据，每个partition可以存在于不同的broker上。Kafka是分布式的架构，所以将topic中不同的数据写到不同分区所属的机器中，和RabbitMQ不一样。

![图片](/Users/cvenwu/baidunetdisk_download/Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师/06_引入消息队列之后该如何保证其高可用性？/视频/04/图片.png)

kafka一个最基本的架构认识：多个broker组成，每个broker是一个节点；你创建一个topic，这个topic可以划分为多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。

这就是天然的分布式消息队列，就是说一个topic的数据，是分散放在多个机器上的，每个机器就放一部分数据。

实际上rabbitmq之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩儿，rabbitmq一个queue的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个queue的完整数据。

kafka 0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法写也没法读，没有什么高可用性可言。

kafka 0.8以后，提供了HA机制，就是replica副本机制。每个partition的数据都会同步到吉他机器上，形成自己的多个replica副本。然后所有replica会选举一个leader出来，那么生产和消费都跟这个leader打交道，然后其他replica就是follower。写的时候，leader会负责把数据同步到所有follower上去，读的时候就直接读leader上数据即可。只能读写leader？很简单，要是你可以随意读写每个follower，那么就要care数据一致性的问题，系统复杂度太高，很容易出问题。kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才可以提高容错性。

这么搞，就有所谓的高可用性了，因为如果某个broker宕机了，没事儿，那个broker上面的partition在其他机器上都有副本的，如果这上面有某个partition的leader，那么此时会重新选举一个新的leader出来，大家继续读写那个新的leader即可。这就有所谓的高可用性了。

写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己主动从leader来pull数据。一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有follower的ack之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）

消费的时候，只会从leader去读，但是只有一个消息已经被所有follower都同步成功返回ack的时候，这个消息才会被消费者读到。

实际上这块机制，讲深了，是可以非常之深入的，但是我还是回到我们这个课程的主题和定位，聚焦面试，至少你听到这里大致明白了kafka是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要遇上面试官确实是kafka高手，深挖了问，那你只能说不好意思，太深入的你没研究过。 

但是大家一定要明白，这个事情是要权衡的，你现在是要快速突击常见面试题体系，而不是要深入学习kafka，要深入学习kafka，你是没那么多时间的。你只能确保，你之前也许压根儿不知道这块，但是现在你知道了，面试被问到，你大概可以说一说。然后很多其他的候选人，也许还不如你，没看过这个，被问到了压根儿答不出来，相比之下，你还能说点出来，大概就是这个意思了。



## 为什么消费到重复数据

### 为什么会被重复消费

> 问题等同于：如何保证消息消费时的幂等性

任何MQ都会发生消息被重复消费的问题，MQ可以保证我们消息不丢失，**但是如何保证收到重复消息系统不出错是我们的事情**。整体原理如下图所示：![图片](/Users/cvenwu/baidunetdisk_download/Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师/07_我的天！我为什么在消息队列里消费到了重复的数据？/视频/01/图片.png)



以Kafka为例，kafka实际上有个offset的概念，就是每个消息写进去，都有一个offset，代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的offset来继续消费吧。举个例子，生产经常遇到的系统会经常重启，看你怎么重启了，如果碰到点着急的，直接kill进程了，再重启。这会导致consumer有些消息处理了，但是没来得及提交offset，尴尬了。重启之后，少数消息会再次消费一次。

### 有了重复消费之后，如何保证幂等性？

> 一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性

![图片](/Users/cvenwu/baidunetdisk_download/Java工程师面试突击第1季（可能是史上最好的Java面试突击课程）-中华石杉老师/07_我的天！我为什么在消息队列里消费到了重复的数据？/视频/02/图片.png)

其实还是得结合业务来思考，我这里给几个思路：

1. 比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update一下好吧
2. 比如你是写redis，那没问题了，反正每次都是set，天然幂等性
3. 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的id，类似订单id之类的东西，然后你这里消费到了之后，先根据这个id去比如redis里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个id写redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。 
4. 基于数据库的唯一键来保证重复数据不会重复插入多条，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会有重复，因为kafka消费者还没来得及提交offset，重复数据拿到了以后我们插入的时候，**因为有唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现脏数据**

**如何保证MQ的消费是幂等性的，需要结合具体的业务来看**



## 为什么发送到消息队列中的消息不见了

> 面试题：如何保证消息的可靠传输
>
> 面试官心理分析：用MQ有个基本原则，就是数据不能多一条，也不能少一条，不能多，就是刚才说的重复消费和幂等性问题。不能少，就是说这数据别搞丢了。





## 如何保证从消息队列里拿到的数据顺序执行





## 消息在消息队列中积压如何处理





## 如果让你开发一个消息队列，你会怎么设计





## 消息队列相关问题的面试技巧







## 自己的疑问

1. 集群和分布式的区别
2. 
