# 计算机网络

!> **计算机网络** 面试题以及答案整理

参考列表
1. 小林图解网络
2. [LeetCode Book](https://leetcode-cn.com/leetbook/read/networks-interview-highlights/ekjhp7/)

---------

## OSI 7层协议 与 五层协议 与4层协议
![IG3irM](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/IG3irM.png)

![XhVdT8](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/XhVdT8.jpg)

### OSI 7层协议：
1. 应用层 ：**为特定应用程序提供数据传输服务**，例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。**在应用层交互的数据单元我们称之为报文**
2. 表示层 ：**作用是使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述。这使得应用程序不必担心在各台计算机中表示和存储的内部格式差异。**
3. 会话层 ：**会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。**
4. 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的 应用层协议。**传输层的主要任务是为两台主机进程之间的通信提供服务。应用程序利用该服务传送应用层报文。该服务并不针对某一特定的应用，多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。**运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，**数据单位为报文段**；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提 供完整性服务，UDP 主要提供及时性服务。 
5. 网络层 ：**为不同网络中的主机提供数据传输服务，网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送**。而传输层协议是为主机中的进程提供数据传输服务。**网络层把传输层传递下来的报文段或者用户数据报封装成分组**。 
6. 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，**链路层协议就是为同一链路(网络)的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。** 数据链路层通常也叫做链路层，在物理层和网络层之间。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。
7. 物理层 ：**物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。**


### 链路层，物理层作用
看上面

### 5层协议

!> 只是在7层协议上去掉会话层与表示层，其中应用层对应 OSI 的上三层，下四层和 OSI 相同

### 4层协议
1. 应用层：**TCP/IP 模型将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。**例如：FTP、Telnet、DNS、SMTP 等。
2. 传输层：该层对应于 OSI 参考模型的传输层，**为上层实体提供源端到对端主机的通信功能**。传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。
3. 网际互联层：网际互联层对应 OSI 参考模型的网络层，**主要负责相同或不同网络中计算机之间的通信**。在网际互联层， IP 协议提供的是一个可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。**除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）**。
4. 网络接入层：网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，**它负责监视数据在主机和网络之间的交换**。

注意：
1. 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。
2. TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。
![epxWaK](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/epxWaK.png)
!> 注意：路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输 层和应用层。

### 路由器、防火墙、交换机处于哪一层
1. 路由器：网络层
2. 防火墙：工作在网络层，传输层，应用层，取决于防火墙的种类
    2.1 过滤型防火墙: 过滤型防火墙是在网络层与传输层中，可以基于数据源头的地址以及协议类型等标志特征进行分析，确定是否可以通过。在符合防火墙规定标准之下，满足安全性能以及类型才可以进行信息的传递，而一些不安全的因素则会被防火墙过滤、阻挡。
    2.2 应用代理防火墙：应用代理防火墙主要的工作范围就是在OIS的最高层，位于应用层之上。其主要的特征是可以完全隔离网络通信流，通过特定的代理程序就可以实现对应用层的监督与控制。
    2.3 复合型防火墙技术：目前应用较为广泛的防火墙技术当属复合型防火墙技术，综合了包过滤防火墙技术以及应用代理防火墙技术的优点，譬如发过来的安全策略是包过滤策略，那么可以针对报文的报头部分进行访问控制；如果安全策略是代理策略，就可以针对报文的内容数据进行访问控制，因此复合型防火墙技术综合了其组成部分的优点，同时摒弃了两种防火墙的原有缺点，大大提高了防火墙技术在应用实践中的灵活性和安全性。
3. 交换机：数据链路层

### 计网转发分组的详细过程
1. 检查ip数据报首部是否出错，出错则丢弃该ip数据报并通告源主机，没有出错则进行转发
2. 若主机与此路由器直接相连，则把数据报直接交付目的主机D；否则是间接交付，执行 (3)。
3. 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 (4)。
4. 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行 (5)。
5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 (6)。
6. 报告转发分组出错。

!> 同一个网络中的主机可以直接进行通信，属于直接交付
!> 不同网络中的主机进行通信，需要通过路由器中转，属于间接交付。

问题：源主机如何判断目的主机与自己在同一个网络中呢？
源主机的ip地址与自己的子网掩码相与就可以得到源主机所在网络的网络地址，目的主机的ip地址与源主机的子网掩码相与就可以得到目的主机所在网络的网络地址，判断两个是否相同，相同就在同一个网络

![x4Mq1d](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/x4Mq1d.png)

对于不在同一个网络中的主机，主机C如何知道应该交给哪个路由器进行转发呢：实际上，用户为了让本网络中的主机与其他网络中的主机进行通信，需要为本网络指定路由器由该路由器进行转发，称作默认网关，我们可以将路由器的其中一个接口的Ip地址指定到该网络中所有主机的默认网关，这样当本网络中的主机与其他网络中的主机进行通信的时候本网络中的主机会将ip数据报栓送给默认网关，由默认网关帮主机将ip数据报转发出去，

假设本例中的主机a要将数据转发给主机d，首先主机a将数据报发送给本网络中的默认网关，也就是图中的路由器，那么路由器收到数据报后如何转发呢？
1. 路由器取出ip数据报中的首部各地址字段的值，源地址字段的值为主机a的ip地址，目的地址字段的值为d的ip地址，
2. 从路由表（当我们给路由器的接口配置ip地址和子网掩码的时候，路由器就知道了自己的该接口与哪个网络直连）中进行查表转发，将目的地址与路由表中的子网掩码相与，如果得到的结果等于路由表中的目的网络的地址则转发到对应路由表条目中的下一跳 ![j9SRox](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/j9SRox.png)
3. 这样主机D就可以收到转发来的数据报了

!> 注意：主机a给本网络中的所有主机发送广播，路由器收到后并不会进行转发。也就是说路由器是隔离广播域的，避免所有的路由器都进行广播造成广播风暴严重浪费因特网资源。当主机a给另一个网络发送广播时，路由器收到判断是广播之后并不会转发

![Np71NA](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Np71NA.png)


### 问了网络的协议栈 为什么要分层
!> 有点类似于分治
分层可以将庞大而复杂的问题转化为若干较小的局部问题，而这些较小的局部问题就便于研究和处理

### OSI 和 TCP/IP 协议之间的对应关系
![Rvsty1](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Rvsty1.png)

### 网络连接的各层的状态
在发送主机端，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。

> 类似问题：数据如何在各层之间传输【数据的封装过程】
---------
## TCP和UDP

对 server 端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发 TCP 连接数超过 10 万 是没问题的

### UDP和TCP 区别
![1CC069D2-AFAA-4B03-857C-55A53DFF4951](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/1CC069D2-AFAA-4B03-857C-55A53DFF4951.png)

   |               UDP(User Datagram Protocol)                |                           TCP(Transmission Control Protocol)                           |
   | :------------------------------------------------------: | :------------------------------------------------------------------------------------: |
   |                          无连接                          |                                        面向连接                                        |
   |          支持一对一，一对多，多对一，多对多通信          | 因为双方需要提前建立连接，因此只能一对一进行通信(全双工：双方随时都可以发送和接收数据) |
   |  面向报文段(对应用层发送的报文段直接添加首部并传送到IP)  |                                       面向字节流                                       |
   | 不保证可靠交付：尽最大努力交付，不使用流量控制和拥塞控制 |         可靠传输，使用确认序号，滑动窗口，流量控制以及拥塞控制等来实现可靠传输         |
   |                      首部只有8字节                       |                             首部最小有20自己，最大有60字节                             |

### TCP可靠性的实现方式
!> TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。

### tcp三次握手 四次挥手
**为什么是三次握手，不是两次和四次？**
1. 主要原因：三次握手才可以阻止重复历史连接的初始化
2. 三次握手才可以同步双方的初始化序列号
3. 三次握手才可以避免资源浪费

两次握手无法放置历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号
四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数


**为什么挥手需要四次：**
1. 假设关闭连接的时候，是客户端向服务端首先发送fin报文，仅仅表示客户端不再发送数据了但是还能接受数据
2. 服务端收到客户端的fin报文之后，先回一个ack应答报文，而服务端还有可能还有数据要处理和发送，等服务端不再发送数据时，才发送fin报文给客户端表示同意现在关闭服务器到客户端的连接

!> 看小林图解网络

### 关于很多TCP面试题的总结
[参考](https://www.nowcoder.com/discuss/530380?source_id=profile_create_nctrack&channel=-1)

### 拥塞控制
慢启动：每次翻倍增加，涨到慢启动门限为止。
拥塞避免：当超过慢启动门限之后就开始拥塞避免算法，每次都是线性增长
拥塞发生：（如何判断拥塞何时发生：出现超时重传(重传计时器超时)以及快速重传(收到3个重复的ACK)），
快速恢复：

快速重传：快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。
![lICD5B](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/lICD5B.png)

流程看图：
![tyl6AA](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/tyl6AA.png)


几种重传的方式：
超时重传
快速重传：快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文 段。![lICD5B](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/lICD5B.png)
SACK：为了解决不知道快速重传该重传哪些 TCP 报文，于是就有 SACK 方法。SACK （ Selective Acknowledgment 选择性确认）。需要在 TCP 头部「选项」字段里加一个 SACK 的东西，**接收方将缓存的地图发送给发送方**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的 数据。
DSACK：**使用了 SACK 来告诉「发送方」有哪些数据被重复接收了**。作用如下：
1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
2. 可以知道是不是「发送方」的数据包被网络延迟了;
3. 可以知道网络中是不是把「发送方」的数据包给复制了;


### 请详细介绍一下TCP的三次握手机制，为什么需要三次握手？
类似问题：TCP 协议了解吗，你给我讲一下三次握手的过程吧
[参考视频](https://www.bilibili.com/video/BV1gk4y1o7pX?t=724)
2个点：

1. 为什么需要握手？
2. 为什么是3次握手？(建连接需要3次握手，关闭连接需要4次握手)

TCP一个重要特性便是可靠性，必须对方告诉说收到消息才算收到消息，不然就会一直重发，互相发的时候如何确定消息发过去呢？给消息进行一个编号叫序列号，序列号不能从0开始，相对随机，需要通过握手同步序列号确定双方都收到消息。

正常是4次，但这里是3次为什么呢？因为建立连接的时候不允许连接处于半打开状态就发送消息，这是TCP所不允许的，其次使用3次连接可以节省一次连接建立的过程。

关连接为什么需要4次？因为关闭一方的连接需要2次握手，并且关闭一方之后另一方仍然可以长时间发送消息，例如server说要关闭之后，client依然可以发送消息。

双工：双方都可以发送接收，比如tcp中的client以及server

单工：只有一方可以发送，比如浏览器服务器

!> 参考视频：自己之前在bilibili看到的极客时间一个老师讲解的视频


### tcp访问一个主机如果主机端口不存在返回什么信息 我说应该是time out吧


### 一个tcp程序的具体步骤

### TIME_WAIT？有什么方法可以避免 TIME_WAIT？TIME_WAIT 是主动断开连接的一方还是被动断开的一方？

time_wait是主动断开连接的一方

类似问题：time_wait

### TCP相关的关闭连接

### TCP最多有几个连接（fd限制+四元组ip、port限制）
![aDjvKW](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/aDjvKW.png)

### 服务端出现大量close_wait原因（主子进程共享socket，close不能完全关闭）
![bNaabs](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/bNaabs.png)


### 那为什么它们的 seq 需要不同的 seq 呢，我可以直接在 seq 上加个 1，把收到的 seq 置为相同的不久行了吗，为什么我服务器端要单独发送自己的 seq 呢

### 为什么建立连接需要三次握手，断开连接需要四次挥手

### 为什么会有一个半关闭的状态，明明客户端已经要求断开连接了呀，你还向客户端发送报（不知道，瞎猜数据没传输完）

### 这个数据没传输完指的什么，客户端请求断开连接的时候数据没有传输完吗，谁的数据没有传输完（尴尬了 2 分多钟）

### TCP 连接他有一个四元组知道吧
四元组是：

       源IP地址、目的IP地址、源端口、目的端口

 

五元组是:
      源IP地址、目的IP地址、协议号、源端口、目的端口


七元组是:

       源IP地址、目的IP地址、协议号、源端口、目的端口，服务类型以及接口索引

协议号:IP是网络层协议，IP头中的协议号用来说明IP报文中承载的是哪种协议,协议号标识上层是什么协议（一般是传输层协议，比如6 TCP，17 UDP；但也可能是网络层协议，比如1 ICMP；也可能是应用层协议，比如89 OSPF）。
TCP/UDP是传输层协议，TCP/UDP的端口号用来说明是哪种上层应用，比如TCP 80代表WWW，TCP 23代表Telnet，UDP 69代表TFTP。
目的主机收到IP包后，根据IP协议号确定送给哪个模块（TCP/UDP/ICMP...）处理，送给TCP/UDP模块的报文根据端口号确定送给哪个应用程序处理。

### TCP 三次握手可以携带数据吗？为什么？
[参考](https://blog.csdn.net/hz___zh/article/details/110130444)

### TCP 和 UDP 稳定性方面的差别?


### TCP 为什么要四次挥手？
前面总结过

### 视频面用的是tcp还是udp，为什么
tcp需要进行三次握手，建立会话需要时间，tcp在网络拥塞的情况下会进行tcp全局同步，根据网络带宽调整tcp滑动窗口大小，引起tcp传输速度下降，甚至有可能会导致tcp报文没有带宽可用，导致tcp饿死，而视频传输对带宽的需求比较大，对时延要求比较高，对丢包率要求不是那么高，udp是面向无连接的传输协议，不需要进行三次握手，也没有tcp的滑动窗口，报文也比tcp小，正好满足了对视频传输的要求。（纯手打）

答案参考：[参考](https://blog.csdn.net/weixin_43167418/article/details/108656273)

### 后面的问题：udp有什么缺点，如何解决？
引申出quic，可以参考：[参考腾讯技术工程知乎文章](https://zhuanlan.zhihu.com/p/32553477)



---------

## Http和Https

### HTTP状态码
1. [官方网站](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
2. ![jcVmoh](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/jcVmoh.png)

类似问题：
1. http302，什么时候会用302，问我实际场景什么时候用302
2. 问我502 答错了 我答成503了
3. http响应状态码
4. 网络状态码
5. 讲一下所知道的状态码，重点说一下 304

### HTTP常见字段有哪些
!> 类似问题： HTTP 协议的头部有哪些属性？

通用信息头
Request URL 请求的地址 域名
Request Method 请求的方法类型 GET / POST
Status Code 响应状态码 200 OK / 404 NOT-FOUND
Remote Address 表示远程服务器地址 IP地址
响应头
Content-Length 响应体的长度
Content-type 返回的响应MIME类型与编码:告诉浏览器它发送的数据属于什么文件类型
Cache-control 指定请求和响应遵循的缓存机制
public 响应可被任何缓存区缓存
private 对于单个用户的整个或部分响应消息，不能被共享缓存处理
no-cache 表示请求或响应消息不能缓存
请求头
Accept 告诉服务器可以接受的文件格式。
Accept-Encoding gzip等指定浏览器可以支持的web服务器返回的内容压缩编码类型。
Accept-Language 浏览器支持的语言。
Cache-Control 指定请求和响应遵循的缓存机制。
Connection keep-alive 表示是否需要持久连接。
Cookie HTTP请求发送时，会把保存在该请求域名下的所有 cookie 值一起发送给web服务器。
Host 指定请求的服务器的域名和端口号。
Referer 告诉服务器是从哪个网站链接过来的。
User-Agent 简称UA。内容包含发出请求的用户信息。
Authorization 当客户端访问受口令保护时，服务器端会发送401状态码和 www-authenticate 响应头，要求客户机使用 Authorization 来应答。
详细属性见文后附表。
一开始答的时候我竟然报了半天状态码还浑然不知，然后看见面试官一脸诧异的看着我才反应过来Orz。重新听了问题后还是没有答出来Orz。



Header	解释	示例
Accept-Ranges	表明服务器是否支持指定范围请求及哪种类型的分段请求	Accept-Ranges: bytes
Age	从原始服务器到代理缓存形成的估算时间（以秒计，非负）	Age: 12
Allow	对某网络资源的有效的请求行为，不允许则返回405	Allow: GET, HEAD
Cache-Control	告诉所有的缓存机制是否可以缓存及哪种类型	Cache-Control: no-cache
Content-Encoding	web服务器支持的返回内容压缩编码类型。	Content-Encoding: gzip
Content-Language	响应体的语言	Content-Language: en,zh
Content-Length	响应体的长度	Content-Length: 348
Content-Location	请求资源可替代的备用的另一地址	Content-Location: /index.htm
Content-MD5	返回资源的MD5校验值	Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==
Content-Range	在整个返回体中本部分的字节位置	Content-Range: bytes 21010-47021/47022
Content-Type	返回内容的MIME类型	Content-Type: text/html; charset=utf-8
Date	原始服务器消息发出的时间	Date: Tue, 01 Nov 2020 08:12:31 GMT
ETag	请求变量的实体标签的当前值	ETag: “737060cd8c284d8af7ad3082f209582d”
Expires	响应过期的日期和时间	Expires: Thu, 01 Dec 2010 16:00:00 GMT
Last-Modified	请求资源的最后修改时间	Last-Modified: Tue, 01 Nov 2020 12:00:00 GMT
Location	用来重定向接收方到非请求URL的位置来完成请求或标识新的资源	Location: http://www.xxx.com/xxx.html
Pragma	包括实现特定的指令，它可应用到响应链上的任何接收方	Pragma: no-cache
Proxy-Authenticate	它指出认证方案和可应用到代理的该URL上的参数	Proxy-Authenticate: Basic
refresh	应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）	Refresh: 5; url=http://www.xxx.com/xxx.html
Retry-After	如果实体暂时不可取，通知客户端在指定时间之后再次尝试	Retry-After: 120
Server	web服务器软件名称	Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)
Set-Cookie	设置Http Cookie	Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1
Trailer	指出头域在分块传输编码的尾部存在	Trailer: Max-Forwards
Transfer-Encoding	文件传输编码	Transfer-Encoding:chunked
Vary	告诉下游代理是使用缓存响应还是从原始服务器请求	Vary: *
Via	告知代理客户端响应是通过哪里发送的	Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
Warning	警告实体可能存在的问题	Warning: 199 Miscellaneous warning
WWW-Authenticate	表明客户端请求实体应该使用的授权方案	WWW-Authenticate: Basic


### HTTP中的请求方法有哪些
![Q1BBEG](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/Q1BBEG.png)

### http请求报文格式 + 响应报文格式
参考cyc2018
![9GHTic](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/9GHTic.png)
![o80BQv](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/o80BQv.png)

### http1.0 http1.1 http2.0 http3.0各自的优缺点

通过http header中的connection字段，如果字段的值是一个closed表明是一个短链接，所有的服务器都会决定，短连接将会在发完response就会关闭连接了。 

如果是长连接将会是**connection: keep-alive**


http1.1 长连接的好处：
1. 减少TCP重复建立以及关闭的开销，减少握手次数
2. 减少慢启动的影响。
3. http1.1会遇到的问题：队头组死啊


队头阻塞：http是基于tcp的，tcp是字符流协议（就是传文件，必须要从头传到尾，但是不能乱），如果一个长连接上传输一个文件是没有问题的，但是一个长连接上传输多个请求，这些请求就会出现串行请求，也就是第一个请求没有传输完成无法开始传输第二个，串行的情况下tcp有一个问题叫**队头阻塞（如果这道题回答道对头阻塞应该就不会延展了）**，只要有一个报文丢包了，后面的即使你传输过去了对方的应用层也不可以接收。


![http2与http1的区别](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/http2%E4%B8%8Ehttp1%E7%9A%84%E5%8C%BA%E5%88%AB.PNG)

[参考](https://zhuanlan.zhihu.com/p/266578819)
参考小林图解网络
#### http1.0 ：
1. 无状态：每次请求服务器不跟踪也每个客户单，也不记录过去的请求（无状态）。这种无状态性可以借助cookie/session机制来做身份认证和状态记录。
2. 无连接：浏览器每次请求都需要与服务器建立一个TCP连接，服务器处理完成以后立即断开TCP连接（无连接），。

存在的问题：
1. 无法复用连接：每次发送请求，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率变低。
2. 队头阻塞（head of line blocking）：由于HTTP1.0规定下一个请求必须在前一个请求响应到达之后才能发送，假设前一个请求响应一直不到达，那么下一个请求就不发送，后面的请求就阻塞了。

#### http1.1：
长连接：HTTP1.1增加Connection字段，通过设置Keep-Alive保持HTTP连接不断卡。避免每次客户端与服务器请求都要重复建立释放建立TCP连接。提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求。

管道传输：通过一个队列将所有请求加入进去，如果某个请求没有收到响应则会阻塞。造成队头阻塞。


性能瓶颈：
1. 请求响应头未经压缩就发送，并且内容量很大造成臃肿
2. 服务器是按照请求的顺序响应的，容易队头阻塞
3. 没有请求优先级控制
4. 请求只能从客户端开始，服务器只能被动响应

#### http2.0
改进：
1. 头部压缩
2. 头部和消息体全部采用二进制
3. 数据流指定的优先级越高会优先响应
4. 服务器推送
5. 多个请求进行复用

#### http3.0 
http1.1的主要问题在于，管道中的某一个请求被阻塞了，后面的都会被阻塞，造成队头阻塞。
http2主要问题在于多个请求复用，一旦某个请求发生丢包，所有的http请求都必须等待这个丢了的包重传回来。

因此http3.0将下面的传输层从tcp改成了udp，因为udp是不可靠的，但是基于udp的quic协议可以实现类似tcp的可靠传输
改进：
1. 某个流丢失的时候，只会阻塞这个流
2. https要建立一个连接由之前的六次握手合并成三次
3. tls升级到了1.3版本，并且头部压缩算法升级成了qpack

### 了解 https 吗？

### ssl 的具体流程

### 对称密钥为什么速度快（没答上来）


### 一个网页的请求过程
类似问题： 输入url发生了什么 或者 用户在浏览器输入网址后到呈现页面的详细步骤

[参考](https://github.com/Bulandent/blog/issues/14)

#### 用户输入阶段
1. 合成 URL：用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容 + 默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL；
2. 加载：用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得；
#### 发起URL请求阶段
1. 构建请求：浏览器进程首先会构建请求行信息，然后通过进程间通信（IPC）将 URL 请求发送给网络进程；
2. 查找缓存：网络进程获取到 URL，先去本地缓存中查找是否有缓存资源，如果有则拦截请求，直接将缓存资源返回给浏览器进程；否则，进入网络请求阶段；
3. DNS 解析：网络进程请求首先会从 DNS 数据缓存服务中查找是否缓存过当前域名信息，有则直接返回；否则，会进行 DNS 解析返回域名对应的 IP 和端口号，如果没有指定端口号，http 默认 80 端口，https 默认 443。如果是 https 请求，还需要建立 TLS 连接；
4. 等待 TCP 队列：Chrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于6个，会直接建立 TCP 连接；
5. 建立 TCP 连接：TCP 三次握手与服务器建立连接，然后进行数据的传输，最后；
6. 发送 HTTP 请求：浏览器首先会向服务器发送请求行，它包含了请求方法、请求 URI 和 HTTP 协议的版本；另外还会发送请求头，告诉服务器一些浏览器的相关信息，比如浏览器内核，请求域名、Cookie 等；如果需要传递参数，则还需要发送请求体；
7. 服务器处理请求：服务器首先返回响应行，包括协议版本和状态码，比如状态码 200 表示继续处理该请求；（如果是 301，则表示重定向，将会在响应头的 Locaiton 字段中加上重定向的地址信息，接下来浏览器获取这个地址，将会重新导航。）服务器也会向浏览器发送响应头，包含了一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等；继续发送响应体的数据；
8. 断开 TCP 连接：数据传输完成，正常情况下 TCP 将四次挥手断开连接。但是如果浏览器或者服务器在HTTP头部加上 Connection: keep-alive，TCP 就会一直保持连接。保持 TCP 连接可以省下下次需要建立连接的时间，提示资源加载速度；
#### 准备渲染进程阶段
1. 网络进程将获取到的数据包进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 text/html 类型，就通知浏览器进程获取到的是 HTML，应该准备渲染进程了；
2. 正常情况下每个浏览器的 tab 会对应一个渲染进程，但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程，否则就会创建一个新的渲染进程；
#### 提交文档阶段
1. 渲染进程准备好后，浏览器会发出 “提交文档” 的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的 “管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程；
2. 浏览器收到 “确认提交” 的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页；
#### 页面渲染阶段
1. 文档一旦提交，渲染进程将开始页面解析和子资源加载；渲染阶段比较复杂，所以将分为多个子阶段，按照渲染的时间顺序可以分为：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成；
2. 构建 DOM 树：HTML 经过解析器后输出一个以 document 为顶层节点的树状结构的 DOM；
3. 样式计算：这里有 3 个步骤：
    1. 将 3 个来源（link 标签引入的外部样式、style 标签里定义的样式、以及元素的 style 属性上的样式）的 CSS 转化成浏览器能够理解的结构 styleSheets；
    2. 转换样式表中的属性值，使其标准化；比如 font-weight: bold; 会转成 font-weight: 700;、color: blue; 会转成 color: rgb(0, 0, 255); 等；
    3. 依据 CSS 的继承和层叠规则计算出 DOM 树中每个节点的具体样式；
4. 布局阶段：DOM 树中依然存在许多不可见的元素（比如 head），这些元素对于布局是丝毫没用的，所以又会生成一棵只包含可见元素的布局树；然后再根据布局树的每个节点计算出其具体位置和尺寸大小；
5. 分层：页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树；关于层叠上下文的知识，具体可以参考这里彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index；
6. 绘制：为每个图层生成绘制列表，并将其提交到合成线程；
7. 光栅化：通常一个页面很大，而视口很局限，所以合成线程会按照视口附近的图块来优先生成位图，并在光栅化线程池中将图块转换成位图；
8. 合成：一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令 DrawQuad，然后将该命令提交给浏览器进程；之后浏览器将开始生成显示页面。



### https和http区别
1. HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全 的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
2. HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3. HTTP 的端口号是 80，HTTPS 的端口号是 443。
4. HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

### https为什么要对称加密 + 非对称加密 + CA机构
具体参考小林图解网络

### https中ssl的握手过程？为什么不一直用非对称加密？
!> 关于为什么不一直用非对称加密？
1. 使用非对称密钥用于传入对称密钥来保证传输过程的安全性，**之后使用对称密钥加密进行通信来保证通信过程的效率**
2. 非对称加密加密解密算法效率较低，不适合客户端和服务器端这样高频率的通信过程，在某些极端情况下，甚至能比非对称加密慢上1000倍。
3. 非对称加密的优势在于它可以很好帮助完成秘钥的交换，所以前期交换秘钥必须使用非对称加密算法

#### 涉及到的知识点：
对称密钥加密：加密和解密使用同一密钥
非对称密钥加密：有一个私有密钥和公有密钥，有两个作用：加密和签名
	1. 加密：发送方使用公有密钥将消息进行加密，之后发送给接收方，接收方使用私有密钥进行解密
 	2. 签名：因为私有密钥无法被其他人获取，通信发送方使用私有密钥进行签名，之后发送给接收方，接收方使用公有密钥解密验证签名是否正确。

对称密钥加密：运算效率高，但是不安全
非对称密钥：可以安全的传输对称密钥，但是运算效率低
**Https采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后用对称密钥加密进行通信保证通信过程的效率**

### http和https在建立连接的时候的区别与联系，https中的s指的是什么？
面经上的答案：
首先客户端通过URL访问服务器并建立SSL连接
服务器收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
客户端的服务端开始协商SSL连接的安全等级，也就是信息加密的等级
客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密并传送给网站
服务器利用自己的私钥解密出会话秘钥
服务器利用会话秘钥加密与客户端之间的通信

### 然后问知道哪些http方法
[同上(HTTP中的请求方法)](./HTTP中的请求方法)

### 了解 HTTP 协议吗？
HTTP 是超文本传输协议，基于 TCP 协议。

### HTTP 协议的连接过程？

1. 请求 TCP 连接：首先，浏览器与 Web 服务器的 HTTP 80端口建立一个 TCP 套接字连接。
2. 发送 HTTP 请求：通过 TCP 连接，浏览器向服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据组成。
3. 接受请求返回响应：Web服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由浏览器读取。一个响应由状态行、响应头部、空行和响应数据组成。
4. 释放TCP连接：
    1. 若 connection 模式为 close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放 TCP 连接
    2. 若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。
5. 解析 HTML 内容：浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

> 当时问到这个回答的很简略，一直准备了 HTTPS 的回答，没想到忽略了基础的 HTTP 协议。


### HTTP1.x 和 HTTP2.0 的区别

![IMG_0389](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/IMG_0389.PNG)

同时参考自己看Bilibili陶辉老师讲解的视频之后自己总结的笔记

### HTTP 缓存（强制缓存、协商缓存）
https://juejin.cn/post/6844903763665240072#heading-0
https://www.cnblogs.com/tugenhua0707/p/10807289.html
https://www.bilibili.com/video/BV11a4y1H7WF?from=search&seid=84378165225275780

### 说一下URL的格式，越详细越好
协议://用户名:密码@子域名.域名.顶级域名:端口号/目录/文件名.文件后缀?参数=值#标志

### get和post

### get与post的区别
    1.  get方法是从服务器获取资源，而post则是向URI指定的资源提交数据，数据就存放在报文的body里面
    2.  get方法是安全和幂等的，而post方法不是安全和幂等的。(安全是指请求方法不会破坏服务器上的资源，幂等是指多次执行相同的操作结果都是相同的。因为post方法每次新增或提交数据的操作都会修改服务器上的资源，所以是不安全的，且多次提交之后就会新建多个资源，所以不是幂等的)

### 服务器server怎么把cookie设置到浏览器的
参考cyc2018基础知识面试中的cookie
![glPGxg](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/glPGxg.png)

### cookie传输

### cookie与session区别

### 多个服务器怎么保存session一致性，
我说使用一个代理保存所有session,然后任意session连接服务器，
面试官问还有没有办法，我说能不能把数据库主从复制一样同步一下session
他说这样破坏了服务器无状态啥的设计原则

### 浏览器刷新界面，服务器如何区分两次相同的请求
我回答的是cookie和session，他说不是这意思，就是从客户端发回来的字节中怎么区分？

### http请求头有什么内容

### http 协议了解吧，session 和 cookie 有什么区别

### 301，302 有什么区别


### url 访问过程
后面的问题：域名解析~呜呜
> 同自己上面整理的。

### HTTP 和 HTTPS 的区别，CA 证书，数字签名，SSL 层握手过程，RSA。


### http断点续传
---------

## 其他问题

### 计算机在设置ip的时候会设置哪些参数
ip地址，子网掩码，网关地址
进阶问题：说说子网掩码以及网关的作用

### 自己简历上写的：ICMP
    1.  参考：https://blog.csdn.net/baidu_37964071/article/details/80514340
    2.  自己总结的笔记

### arp协议

### 说说你所知道的网络定时器的机制

### DNS协议
![CB0O61](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/CB0O61.png)
![QzZJXC](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/QzZJXC.png)

### DNS 是什么？DNS 的查询过程？
面经上的回答：
DNS 是域名系统，通常用来解析域名为 IP 地址。
本地解析 通过本地缓存进行解析。
直接解析 向客户机所设定的局部 DNS 服务器发一个查询请求。
递归解析 局部 DNS 服务器向该域名的根域服务器查询，再由根域名服务器一级级向下查询。
迭代解析 局部 DNS 服务器把请求转发至上一级 DNS 服务器，再请求上上级直到查询到该域名。
当时只回答了递归解析和迭代解析，其实还有 Host 文件、本地和直接解析

类似问题：
1. DNS的工作流程

![X6HxO2](https://cdn.jsdelivr.net/gh/sivanWu0222/ImageHosting@master/uPic/X6HxO2.png)

### ICMP 这个协议他位于网络的第几层知道吧

### 那链路层的协议有哪些啊

### 讲讲ping命令用到了哪些协议


## 还没有整理的

#### 同样问到了 url 访问原理，但是很细节，比如 dns 的原理，在路由器上找的时候，有哪几 种情况

#### http 跟 tcp 是什么关系


视频面用的是 TCP 还是 UDP，为什么？

UDP 有什么缺点？怎么解决？

Http 请求头有什么内容？


拥塞控制及对应方法的使用场景

7、session 和 cookie 的区别

TCP 流量控制和拥塞控制？

4. Time_wait 有什么用（面试官补充了一个教科书上没有提到的作用，关于网络异常、数

据失序的辨识）

5. nagle 算法了解么？


如何改进 UDP 的不可靠传输，保证数据有序性？

2. TCP 三次握手和四次挥手的描述


TCP 握手和挥手，UDP 和 TCP，如果要用 udp 发送一个比较大的文件该如何操作，如 何确定文件是否发送完成，是否有丢失，如何对接收到的数据包进行组装，编号如何存 放，用什么数据结构。

RESTful 简介与优点（优点记不得了呀，就随便说了一下……）

TCP 和 UDP 的优缺点，TCP 滑动窗口


4.tcp 的四次握手，timewait2 的状态是什么情况，为什么会出现大量的 timewait2？


如何处理 get 和 post

tcp 接收窗口和拥塞窗口

什么时候会向对端传窗口大小

假设 rtt（数据从两端一来一回） 100ms，那么从输入一个 http://url 到得到网页要多少时间

https 呢？

连续发送两次 http 请求，会得到两次结果吗？可能第二次比第一次快吗？

是否了解 TCP 包头阻塞?

服务器状态 502 503 504 什么问题，怎么排查

netstat 具体查看什么问题



ack 什么时候发送，丢失了会怎么样？

sack 了解吗？

重传 ack 的时机只有 ack 超时吗？

重复报文被接收会发生什么？

拥塞窗口要不要把自己的大小发给接收方，意义何在？（这个问题一面也问了，没有答出 来）

延迟 ACK 的意义在哪？

为什么不能每次都直接发大的窗口？


http 了解多少？

http 缓存机制了解吗？

长连接讲一下

如何实现长连接（保活）

带外数据如何使用？


http 传入的 Request 和返回的 Response

503 和 500 区别。301 和 302 区别

http close-wait 状态


滑动窗口和 TCP 流量控制

如果滑动窗口为 0，则怎么办

TCP 连接为啥不能 2 次握手，找个 bug cases


tcp 标头有什么东西

子网掩码有什么用

mac 寻址等


tcp 的连接，怎么用 udp 模拟 tcp


4.了解过拥塞控制吗，我说不太记得了，只知道有个到阈值降一半然后线性增长


Http/断点续传

什么场景下使用 UDP？为什么？


linux下如何查看一个服务的连接数目


了解quic
了解DNS
了解ping

了解ICMP